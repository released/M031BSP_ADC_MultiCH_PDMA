; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC_IRQHandler PROC
;;;203    
;;;204    void ADC_IRQHandler(void)
000000  4901              LDR      r1,|L1.8|
;;;205    {
;;;206        ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT); /* Clear the A/D interrupt flag */
000002  2001              MOVS     r0,#1
000004  6108              STR      r0,[r1,#0x10]
;;;207    }
000006  4770              BX       lr
;;;208    
                          ENDP

                  |L1.8|
                          DCD      0x40043080

                          AREA ||i.ADC_InitChannel||, CODE, READONLY, ALIGN=2

                  ADC_InitChannel PROC
;;;239    
;;;240    void ADC_InitChannel(uint8_t ch)
000000  b570              PUSH     {r4-r6,lr}
;;;241    {
;;;242    	set_flag(flag_ADC_Data_Ready,DISABLE);
000002  4912              LDR      r1,|L2.76|
000004  68ca              LDR      r2,[r1,#0xc]  ; BitFlag
000006  0852              LSRS     r2,r2,#1
000008  0052              LSLS     r2,r2,#1
00000a  60ca              STR      r2,[r1,#0xc]  ; BitFlag
;;;243    
;;;244    //	ADC_ReadAVdd();
;;;245    
;;;246        /* Enable ADC converter */
;;;247    //    ADC_POWER_ON(ADC);
;;;248    
;;;249        /*Wait for ADC internal power ready*/
;;;250    //    CLK_SysTickDelay(10000);
;;;251    
;;;252        /* Set input mode as single-end, and Single mode*/
;;;253        ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE,(uint32_t) 0x1 << ch);
00000c  2301              MOVS     r3,#1
00000e  4083              LSLS     r3,r3,r0
000010  4d0f              LDR      r5,|L2.80|
000012  2200              MOVS     r2,#0
000014  461c              MOV      r4,r3
000016  4611              MOV      r1,r2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       ADC_Open
;;;254    
;;;255        /* To sample band-gap precisely, the ADC capacitor must be charged at least 3 us for charging the ADC capacitor ( Cin )*/
;;;256        /* Sampling time = extended sampling time + 1 */
;;;257        /* 1/24000000 * (Sampling time) = 3 us */
;;;258    	/*
;;;259    	    printf("+----------------------------------------------------------------------+\n");
;;;260    	    printf("|   ADC clock source -> PCLK1  = 48 MHz                                |\n");
;;;261    	    printf("|   ADC clock divider          = 2                                     |\n");
;;;262    	    printf("|   ADC clock                  = 48 MHz / 2 = 24 MHz                   |\n");
;;;263    	    printf("|   ADC extended sampling time = 71                                    |\n");
;;;264    	    printf("|   ADC conversion time = 17 + ADC extended sampling time = 88         |\n");
;;;265    	    printf("|   ADC conversion rate = 24 MHz / 88 = 272.7 ksps                     |\n");
;;;266    	    printf("+----------------------------------------------------------------------+\n");
;;;267    	*/
;;;268    
;;;269        /* Set extend sampling time based on external resistor value.*/
;;;270        ADC_SetExtendSampleTime(ADC,(uint32_t) NULL, ADCextendSampling);
00001e  220a              MOVS     r2,#0xa
000020  2100              MOVS     r1,#0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       ADC_SetExtendSampleTime
;;;271    
;;;272        /* Select ADC input channel */
;;;273        ADC_SET_INPUT_CHANNEL(ADC, 0x1 << ch);
000028  4809              LDR      r0,|L2.80|
00002a  3080              ADDS     r0,r0,#0x80
00002c  6841              LDR      r1,[r0,#4]
00002e  6044              STR      r4,[r0,#4]
;;;274    
;;;275        /* ADC enable PDMA transfer */
;;;276        ADC_ENABLE_PDMA(ADC);
000030  6801              LDR      r1,[r0,#0]
000032  1542              ASRS     r2,r0,#21
000034  4311              ORRS     r1,r1,r2
000036  6001              STR      r1,[r0,#0]
;;;277    
;;;278        /* Start ADC conversion */
;;;279        ADC_START_CONV(ADC);
000038  6801              LDR      r1,[r0,#0]
00003a  14c2              ASRS     r2,r0,#19
00003c  4311              ORRS     r1,r1,r2
00003e  6001              STR      r1,[r0,#0]
;;;280    	
;;;281        /* reload PDMA configuration for next transmission */
;;;282        ReloadPDMA();	
000040  f7fffffe          BL       ReloadPDMA
;;;283    
;;;284    	MONITOR_PIN = 0;	
000044  4903              LDR      r1,|L2.84|
000046  2000              MOVS     r0,#0
000048  63c8              STR      r0,[r1,#0x3c]
;;;285    }
00004a  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP

                  |L2.76|
                          DCD      ||.data||
                  |L2.80|
                          DCD      0x40043000
                  |L2.84|
                          DCD      0x40004840

                          AREA ||i.ADC_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  ADC_Process PROC
;;;287    
;;;288    void ADC_Process(uint8_t state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;289    {
;;;290    	uint8_t idx = 0;
000002  2400              MOVS     r4,#0
;;;291    	volatile	uint32_t sum = 0;
;;;292    	uint16_t tmp = 0;
;;;293    	
;;;294    	switch(state)
;;;295    	{
;;;296    		case State_avergage:	
;;;297    			for ( idx = 0 ; idx < ADC_CH_NUM ; idx++)
;;;298    			{
;;;299    				ADC_TargetChannel = adc_measure[idx].adc_ch;
000004  4d2d              LDR      r5,|L3.188|
;;;300    				for ( tmp = 0 ; tmp < ADC_AVG_TRAGET ; tmp++)
;;;301    				{
;;;302    					ADC_InitChannel(ADC_TargetChannel);
;;;303    					while(!is_flag_set(flag_ADC_Data_Ready));
;;;304    					MONITOR_PIN = 0;
;;;305    					
;;;306    					sum += PDMAConvertedData;									//sum the first 8 ADC data
;;;307    				}
;;;308    				ADC_DataArray[idx] = (uint16_t) (sum >> ADC_AVG_POW);			//do average
000006  4e2e              LDR      r6,|L3.192|
000008  4627              MOV      r7,r4                 ;291
00000a  9400              STR      r4,[sp,#0]            ;294
00000c  2800              CMP      r0,#0                 ;294
00000e  d002              BEQ      |L3.22|
000010  2801              CMP      r0,#1                 ;294
000012  d11f              BNE      |L3.84|
000014  e01f              B        |L3.86|
                  |L3.22|
000016  4f2b              LDR      r7,|L3.196|
                  |L3.24|
000018  482b              LDR      r0,|L3.200|
00001a  5d00              LDRB     r0,[r0,r4]            ;299
00001c  8028              STRH     r0,[r5,#0]            ;299
00001e  2600              MOVS     r6,#0                 ;300
                  |L3.32|
000020  8828              LDRH     r0,[r5,#0]            ;302  ; ADC_TargetChannel
000022  b2c0              UXTB     r0,r0                 ;302
000024  f7fffffe          BL       ADC_InitChannel
                  |L3.40|
000028  68e8              LDR      r0,[r5,#0xc]          ;303  ; BitFlag
00002a  07c0              LSLS     r0,r0,#31             ;303
00002c  d0fc              BEQ      |L3.40|
00002e  2000              MOVS     r0,#0                 ;304
000030  63f8              STR      r0,[r7,#0x3c]         ;304
000032  8869              LDRH     r1,[r5,#2]            ;306  ; PDMAConvertedData
000034  9800              LDR      r0,[sp,#0]            ;306
000036  1c76              ADDS     r6,r6,#1              ;306
000038  1840              ADDS     r0,r0,r1              ;306
00003a  b2b6              UXTH     r6,r6                 ;300
00003c  9000              STR      r0,[sp,#0]            ;300
00003e  2e08              CMP      r6,#8                 ;300
000040  d3ee              BCC      |L3.32|
000042  0340              LSLS     r0,r0,#13
000044  0062              LSLS     r2,r4,#1
000046  0c01              LSRS     r1,r0,#16
000048  481d              LDR      r0,|L3.192|
00004a  1c64              ADDS     r4,r4,#1
00004c  b2e4              UXTB     r4,r4                 ;297
00004e  5281              STRH     r1,[r0,r2]
000050  2c07              CMP      r4,#7                 ;297
000052  d3e1              BCC      |L3.24|
                  |L3.84|
;;;309    			}
;;;310    
;;;311    			break;
;;;312    
;;;313    		case State_moving:
;;;314    			for ( idx = 0 ; idx < ADC_CH_NUM ; idx++)
;;;315    			{
;;;316    				ADC_TargetChannel = adc_measure[idx].adc_ch;
;;;317    				ADC_InitChannel(ADC_TargetChannel);
;;;318    				while(!is_flag_set(flag_ADC_Data_Ready));
;;;319    				MONITOR_PIN = 0;
;;;320    				
;;;321    				sum = ADC_DataArray[idx] << ADC_AVG_POW;						//extend the original average data
;;;322    				sum -= ADC_DataArray[idx];										//subtract the old average data
;;;323    				sum += PDMAConvertedData;										//add the new adc data
;;;324    				ADC_DataArray[idx] = (uint16_t) (sum >> ADC_AVG_POW);			//do average again
;;;325    		
;;;326    			}
;;;327    
;;;328    			#if 1	// debug
;;;329    			for ( idx = 0 ; idx < ADC_CH_NUM ; idx++)
;;;330    			{
;;;331    				tmp = ADC_DataArray[idx];
;;;332    //				convertDecToBin(tmp);//ADC_DataArray[idx]
;;;333    //				printf("%d:%4dmv," , idx ,ADC_CALC_DATA_TO_VOLTAGE(ADC_DataArray[idx],ADC_REF_VOLTAGE));
;;;334    //				printf("%d:%3X,%4d ," , idx ,ADC_DataArray[idx],ADC_CALC_DATA_TO_VOLTAGE(ADC_DataArray[idx],ADC_REF_VOLTAGE));
;;;335    //				printf("%d:0x%3X," , 4 , ADC_DataArray[idx]);
;;;336    				printf("%3X:%4d ," , tmp ,ADC_CALC_DATA_TO_VOLTAGE(tmp,ADC_REF_VOLTAGE));
;;;337    //				printf("%2X:%2X ," , adc_measure[idx].adc_ch,ADC_DataArray[idx]);
;;;338    				
;;;339    				if (idx == (ADC_CH_NUM -1) )
;;;340    				{
;;;341    					printf("\r\n");
;;;342    				}				
;;;343    			}
;;;344    			#endif	
;;;345    			
;;;346    			break;
;;;347    		
;;;348    		
;;;349    	}
;;;350    	
;;;351    }
000054  bdf8              POP      {r3-r7,pc}
                  |L3.86|
000056  481c              LDR      r0,|L3.200|
000058  5d00              LDRB     r0,[r0,r4]            ;316
00005a  8028              STRH     r0,[r5,#0]            ;316
00005c  8828              LDRH     r0,[r5,#0]            ;317  ; ADC_TargetChannel
00005e  b2c0              UXTB     r0,r0                 ;317
000060  f7fffffe          BL       ADC_InitChannel
                  |L3.100|
000064  68e8              LDR      r0,[r5,#0xc]          ;318  ; BitFlag
000066  07c0              LSLS     r0,r0,#31             ;318
000068  d0fc              BEQ      |L3.100|
00006a  4816              LDR      r0,|L3.196|
00006c  63c7              STR      r7,[r0,#0x3c]         ;319
00006e  0060              LSLS     r0,r4,#1              ;321
000070  5a31              LDRH     r1,[r6,r0]            ;321
000072  00ca              LSLS     r2,r1,#3              ;321
000074  1a51              SUBS     r1,r2,r1              ;322
000076  9100              STR      r1,[sp,#0]            ;323
000078  886a              LDRH     r2,[r5,#2]            ;323  ; PDMAConvertedData
00007a  1c64              ADDS     r4,r4,#1              ;324
00007c  1889              ADDS     r1,r1,r2              ;323
00007e  9100              STR      r1,[sp,#0]            ;324
000080  0349              LSLS     r1,r1,#13             ;324
000082  0c09              LSRS     r1,r1,#16             ;324
000084  b2e4              UXTB     r4,r4                 ;314
000086  5231              STRH     r1,[r6,r0]            ;324
000088  2c07              CMP      r4,#7                 ;314
00008a  d3e4              BCC      |L3.86|
00008c  4f0f              LDR      r7,|L3.204|
00008e  2400              MOVS     r4,#0                 ;329
                  |L3.144|
000090  0060              LSLS     r0,r4,#1              ;331
000092  5a35              LDRH     r5,[r6,r0]            ;331
000094  480e              LDR      r0,|L3.208|
000096  4639              MOV      r1,r7                 ;336
000098  4368              MULS     r0,r5,r0              ;336
00009a  f7fffffe          BL       __aeabi_uidivmod
00009e  4602              MOV      r2,r0                 ;336
0000a0  4629              MOV      r1,r5                 ;336
0000a2  a00c              ADR      r0,|L3.212|
0000a4  f7fffffe          BL       __2printf
0000a8  2c06              CMP      r4,#6                 ;339
0000aa  d102              BNE      |L3.178|
0000ac  a00c              ADR      r0,|L3.224|
0000ae  f7fffffe          BL       __2printf
                  |L3.178|
0000b2  1c64              ADDS     r4,r4,#1              ;341
0000b4  b2e4              UXTB     r4,r4                 ;329
0000b6  2c07              CMP      r4,#7                 ;329
0000b8  d3ea              BCC      |L3.144|
0000ba  bdf8              POP      {r3-r7,pc}
;;;352    
                          ENDP

                  |L3.188|
                          DCD      ||.data||
                  |L3.192|
                          DCD      ||.bss||
                  |L3.196|
                          DCD      0x40004840
                  |L3.200|
                          DCD      ||.constdata||
                  |L3.204|
                          DCD      0x00000fff
                  |L3.208|
                          DCD      0x00000ce4
                  |L3.212|
0000d4  2533583a          DCB      "%3X:%4d ,",0
0000d8  25346420
0000dc  2c00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
0000e0  0d0a00            DCB      "\r\n",0
0000e3  00                DCB      0

                          AREA ||i.ADC_ReadAVdd||, CODE, READONLY, ALIGN=2

                  ADC_ReadAVdd PROC
;;;208    
;;;209    void ADC_ReadAVdd(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;210    {
;;;211        int32_t  i32ConversionData;
;;;212        int32_t  i32BuiltInData;
;;;213    
;;;214        ADC_POWER_ON(ADC);
000002  4d22              LDR      r5,|L4.140|
000004  6828              LDR      r0,[r5,#0]
000006  2601              MOVS     r6,#1
000008  4330              ORRS     r0,r0,r6
00000a  6028              STR      r0,[r5,#0]
;;;215        CLK_SysTickDelay(10000);
00000c  4820              LDR      r0,|L4.144|
00000e  f7fffffe          BL       CLK_SysTickDelay
;;;216    
;;;217    	
;;;218        ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT29);
000012  4f1e              LDR      r7,|L4.140|
000014  05ac              LSLS     r4,r5,#22
000016  2200              MOVS     r2,#0
000018  3f80              SUBS     r7,r7,#0x80
00001a  4623              MOV      r3,r4
00001c  4611              MOV      r1,r2
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       ADC_Open
;;;219        ADC_SetExtendSampleTime(ADC, 0, 71);
000024  2247              MOVS     r2,#0x47
000026  2100              MOVS     r1,#0
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       ADC_SetExtendSampleTime
;;;220        ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
00002e  612e              STR      r6,[r5,#0x10]
;;;221        ADC_ENABLE_INT(ADC, ADC_ADF_INT);
000030  2101              MOVS     r1,#1
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       ADC_EnableInt
000038  4816              LDR      r0,|L4.148|
00003a  6004              STR      r4,[r0,#0]
;;;222        NVIC_EnableIRQ(ADC_IRQn);
;;;223        ADC_START_CONV(ADC);
00003c  6828              LDR      r0,[r5,#0]
00003e  14a1              ASRS     r1,r4,#18
000040  4308              ORRS     r0,r0,r1
000042  6028              STR      r0,[r5,#0]
;;;224    
;;;225        ADC_DISABLE_INT(ADC, ADC_ADF_INT);
000044  2101              MOVS     r1,#1
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       ADC_DisableInt
;;;226    		
;;;227        i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 29);
00004c  480f              LDR      r0,|L4.140|
00004e  3840              SUBS     r0,r0,#0x40
000050  6b40              LDR      r0,[r0,#0x34]
000052  b285              UXTH     r5,r0
;;;228        SYS_UnlockReg();
000054  f7fffffe          BL       SYS_UnlockReg
;;;229        FMC_Open();
000058  f7fffffe          BL       FMC_Open
00005c  480e              LDR      r0,|L4.152|
00005e  2104              MOVS     r1,#4
000060  60c1              STR      r1,[r0,#0xc]
000062  2170              MOVS     r1,#0x70
000064  6041              STR      r1,[r0,#4]
000066  6106              STR      r6,[r0,#0x10]
                  |L4.104|
000068  6902              LDR      r2,[r0,#0x10]
00006a  07d1              LSLS     r1,r2,#31
00006c  d1fc              BNE      |L4.104|
00006e  6880              LDR      r0,[r0,#8]
;;;230        i32BuiltInData = FMC_ReadBandGap();	
;;;231    
;;;232    	AVdd = 3072*i32BuiltInData/i32ConversionData;
000070  2103              MOVS     r1,#3
000072  0500              LSLS     r0,r0,#20
000074  0d00              LSRS     r0,r0,#20
000076  0289              LSLS     r1,r1,#10
000078  4348              MULS     r0,r1,r0
00007a  4629              MOV      r1,r5
00007c  f7fffffe          BL       __aeabi_idivmod
000080  4906              LDR      r1,|L4.156|
000082  6088              STR      r0,[r1,#8]  ; AVdd
000084  4803              LDR      r0,|L4.148|
000086  3080              ADDS     r0,r0,#0x80
000088  6004              STR      r4,[r0,#0]
;;;233    
;;;234    //	printf("%s : %d,%d,%d\r\n",__FUNCTION__,AVdd, i32ConversionData,i32BuiltInData);
;;;235    
;;;236        NVIC_DisableIRQ(ADC_IRQn);
;;;237    	
;;;238    }
00008a  bdf8              POP      {r3-r7,pc}
;;;239    
                          ENDP

                  |L4.140|
                          DCD      0x40043080
                  |L4.144|
                          DCD      0x00002710
                  |L4.148|
                          DCD      0xe000e100
                  |L4.152|
                          DCD      0x4000c000
                  |L4.156|
                          DCD      ||.data||

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;504      */
;;;505    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L5.28|
;;;506    {
;;;507        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L5.32|
000008  6148              STR      r0,[r1,#0x14]
;;;508        SysTick->VAL  = (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;509        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L5.18|
;;;510    
;;;511        /* Waiting for down-count to zero */
;;;512        while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L5.18|
;;;513    
;;;514        /* Disable SysTick counter */
;;;515        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;516    }
00001a  4770              BX       lr
;;;517    
                          ENDP

                  |L5.28|
                          DCD      CyclesPerUs
                  |L5.32|
                          DCD      0xe000e000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;353    
;;;354    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;355    {
;;;356        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  4c06              LDR      r4,|L6.28|
000004  2201              MOVS     r2,#1
000006  0391              LSLS     r1,r2,#14
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;357    
;;;358        GPIO_SetMode(PB, BIT15, GPIO_MODE_OUTPUT);	
00000e  2201              MOVS     r2,#1
000010  03d1              LSLS     r1,r2,#15
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;359    }
000018  bd10              POP      {r4,pc}
;;;360    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40004040

                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  PDMA_IRQHandler PROC
;;;117    
;;;118    void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4c10              LDR      r4,|L7.68|
000004  69e0              LDR      r0,[r4,#0x1c]
;;;121    
;;;122        if(status & PDMA_INTSTS_ABTIF_Msk)    /* abort */
;;;123        {
;;;124            if(PDMA_GET_ABORT_STS(PDMA) & PDMA_CH_MASK_ADC)
;;;125            {
;;;126    			printf("%s abort\r\n" , __FUNCTION__);
;;;127            }
;;;128            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_CH_MASK_ADC);
000006  2510              MOVS     r5,#0x10
000008  07c1              LSLS     r1,r0,#31             ;122
00000a  2900              CMP      r1,#0                 ;122
00000c  d008              BEQ      |L7.32|
00000e  6a20              LDR      r0,[r4,#0x20]         ;124
000010  06c0              LSLS     r0,r0,#27             ;124
000012  d503              BPL      |L7.28|
000014  490c              LDR      r1,|L7.72|
000016  a00d              ADR      r0,|L7.76|
000018  f7fffffe          BL       __2printf
                  |L7.28|
00001c  6225              STR      r5,[r4,#0x20]
;;;129        }
;;;130        else if(status & PDMA_INTSTS_TDIF_Msk)      /* done */
;;;131        {
;;;132            if(PDMA_GET_TD_STS(PDMA) & PDMA_CH_MASK_ADC)
;;;133            {
;;;134    //			printf("%s done\r\n" , __FUNCTION__);
;;;135    			set_flag(flag_ADC_Data_Ready,ENABLE);
;;;136    			MONITOR_PIN = 1;
;;;137            }
;;;138            PDMA_CLR_TD_FLAG(PDMA, PDMA_CH_MASK_ADC);
;;;139        }
;;;140        else
;;;141            printf("unknown PDMA interrupt !!\n");
;;;142    }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  0780              LSLS     r0,r0,#30             ;130
000022  d50b              BPL      |L7.60|
000024  6a60              LDR      r0,[r4,#0x24]         ;132
000026  06c0              LSLS     r0,r0,#27             ;132
000028  d506              BPL      |L7.56|
00002a  490b              LDR      r1,|L7.88|
00002c  68ca              LDR      r2,[r1,#0xc]          ;135  ; BitFlag
00002e  2001              MOVS     r0,#1                 ;135
000030  4302              ORRS     r2,r2,r0              ;135
000032  60ca              STR      r2,[r1,#0xc]          ;135  ; BitFlag
000034  4909              LDR      r1,|L7.92|
000036  63c8              STR      r0,[r1,#0x3c]         ;136
                  |L7.56|
000038  6265              STR      r5,[r4,#0x24]         ;138
00003a  bd70              POP      {r4-r6,pc}
                  |L7.60|
00003c  a008              ADR      r0,|L7.96|
00003e  f7fffffe          BL       __2printf
000042  bd70              POP      {r4-r6,pc}
;;;143    
                          ENDP

                  |L7.68|
                          DCD      0x40008400
                  |L7.72|
                          DCD      ||.constdata||+0x8
                  |L7.76|
00004c  25732061          DCB      "%s abort\r\n",0
000050  626f7274
000054  0d0a00  
000057  00                DCB      0
                  |L7.88|
                          DCD      ||.data||
                  |L7.92|
                          DCD      0x40004840
                  |L7.96|
000060  756e6b6e          DCB      "unknown PDMA interrupt !!\n",0
000064  6f776e20
000068  50444d41
00006c  20696e74
000070  65727275
000074  70742021
000078  210a00  
00007b  00                DCB      0

                          AREA ||i.PDMA_Init||, CODE, READONLY, ALIGN=2

                  PDMA_Init PROC
;;;143    
;;;144    void PDMA_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;145    {
;;;146        /* Configure PDMA peripheral mode form ADC to memory */
;;;147        /* Open PDMA Channel 4 based on PDMA_CH_ADC setting*/
;;;148        PDMA_Open(PDMA, PDMA_CH_MASK_ADC);
000002  4d16              LDR      r5,|L8.92|
000004  2110              MOVS     r1,#0x10
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       PDMA_Open
;;;149    
;;;150        /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;151        PDMA_SetTransferCnt(PDMA, PDMA_CH_ADC, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
00000c  2301              MOVS     r3,#1
00000e  031a              LSLS     r2,r3,#12
000010  2104              MOVS     r1,#4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       PDMA_SetTransferCnt
;;;152    
;;;153        /* Set source address as ADC data register (no increment) and destination address as g_i32ConversionData array (increment) */
;;;154        PDMA_SetTransferAddr(PDMA, PDMA_CH_ADC, (uint32_t)&ADC->ADPDMA, PDMA_SAR_FIX, (uint32_t)&PDMAConvertedData, PDMA_DAR_INC);
000018  4911              LDR      r1,|L8.96|
00001a  2400              MOVS     r4,#0
00001c  2303              MOVS     r3,#3
00001e  9100              STR      r1,[sp,#0]
000020  021b              LSLS     r3,r3,#8
000022  4a10              LDR      r2,|L8.100|
000024  9401              STR      r4,[sp,#4]
000026  2104              MOVS     r1,#4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferAddr
;;;155    
;;;156        /* Select PDMA request source as ADC RX */
;;;157        PDMA_SetTransferMode(PDMA, PDMA_CH_ADC, PDMA_ADC_RX, FALSE, 0);
00002e  2300              MOVS     r3,#0
000030  2214              MOVS     r2,#0x14
000032  2104              MOVS     r1,#4
000034  4628              MOV      r0,r5
000036  9400              STR      r4,[sp,#0]
000038  f7fffffe          BL       PDMA_SetTransferMode
;;;158    
;;;159        /* Set PDMA as single request type for ADC */
;;;160        PDMA_SetBurstType(PDMA, PDMA_CH_ADC, PDMA_REQ_SINGLE, 0);
00003c  2204              MOVS     r2,#4
00003e  2300              MOVS     r3,#0
000040  4611              MOV      r1,r2
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       PDMA_SetBurstType
;;;161    
;;;162        PDMA_EnableInt(PDMA, PDMA_CH_ADC, PDMA_INT_TRANS_DONE);
000048  2200              MOVS     r2,#0
00004a  2104              MOVS     r1,#4
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       PDMA_EnableInt
000052  4905              LDR      r1,|L8.104|
000054  02e8              LSLS     r0,r5,#11
000056  6008              STR      r0,[r1,#0]
;;;163        NVIC_EnableIRQ(PDMA_IRQn);
;;;164    
;;;165    
;;;166    }
000058  bd7c              POP      {r2-r6,pc}
;;;167    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      0x40008000
                  |L8.96|
                          DCD      ||.data||+0x2
                  |L8.100|
                          DCD      0x40043100
                  |L8.104|
                          DCD      0xe000e100

                          AREA ||i.ReloadPDMA||, CODE, READONLY, ALIGN=2

                  ReloadPDMA PROC
;;;108    
;;;109    void ReloadPDMA(void)
000000  b538              PUSH     {r3-r5,lr}
;;;110    {
;;;111        /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;112        PDMA_SetTransferCnt(PDMA, PDMA_CH_ADC, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
000002  4c08              LDR      r4,|L9.36|
000004  2301              MOVS     r3,#1
000006  031a              LSLS     r2,r3,#12
000008  2104              MOVS     r1,#4
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PDMA_SetTransferCnt
;;;113    
;;;114        /* Select PDMA request source as ADC RX */
;;;115        PDMA_SetTransferMode(PDMA, PDMA_CH_ADC, PDMA_ADC_RX, FALSE, (uint32_t) NULL);
000010  2100              MOVS     r1,#0
000012  460b              MOV      r3,r1
000014  9100              STR      r1,[sp,#0]
000016  2214              MOVS     r2,#0x14
000018  2104              MOVS     r1,#4
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       PDMA_SetTransferMode
;;;116    }
000020  bd38              POP      {r3-r5,pc}
;;;117    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40008000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;406    
;;;407    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;408    {
;;;409        /* Unlock protected registers */
;;;410        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;411    
;;;412        /* Enable HIRC clock (Internal RC 48MHz) */
;;;413        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;414    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;415    	
;;;416        /* Wait for HIRC clock ready */
;;;417        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;418    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;419    	
;;;420        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;421        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;422    
;;;423        /* Enable UART0 clock */
;;;424        CLK_EnableModuleClock(UART0_MODULE);
00001a  4c27              LDR      r4,|L10.184|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       CLK_EnableModuleClock
;;;425        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000022  2101              MOVS     r1,#1
000024  2200              MOVS     r2,#0
000026  0689              LSLS     r1,r1,#26
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CLK_SetModuleClock
;;;426    	
;;;427        CLK_EnableModuleClock(TMR3_MODULE);
00002e  4d23              LDR      r5,|L10.188|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       CLK_EnableModuleClock
;;;428        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000036  2401              MOVS     r4,#1
000038  0564              LSLS     r4,r4,#21
00003a  2200              MOVS     r2,#0
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_SetModuleClock
;;;429    	
;;;430        CLK_EnableModuleClock(ADC_MODULE);	
000044  4d1e              LDR      r5,|L10.192|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;431        CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL2_ADCSEL_PCLK1, CLK_CLKDIV0_ADC(12));
00004c  220b              MOVS     r2,#0xb
00004e  0412              LSLS     r2,r2,#16
000050  4621              MOV      r1,r4
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;432    	
;;;433        /* Enable PDMA clock source */
;;;434        CLK_EnableModuleClock(PDMA_MODULE);
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       CLK_EnableModuleClock
;;;435    
;;;436        /* Update System Core Clock */
;;;437        SystemCoreClockUpdate();
00005e  f7fffffe          BL       SystemCoreClockUpdate
;;;438    
;;;439        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;440        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000062  0260              LSLS     r0,r4,#9
000064  6bc1              LDR      r1,[r0,#0x3c]
000066  22ff              MOVS     r2,#0xff
000068  0412              LSLS     r2,r2,#16
00006a  4391              BICS     r1,r1,r2
00006c  2233              MOVS     r2,#0x33
00006e  0452              LSLS     r2,r2,#17
000070  1889              ADDS     r1,r1,r2
000072  63c1              STR      r1,[r0,#0x3c]
;;;441                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;442    
;;;443        SYS->GPB_MFPL = (SYS->GPB_MFPL &~(SYS_GPB_MFPL_PB6MFP_Msk )) \
000074  6b81              LDR      r1,[r0,#0x38]
000076  220f              MOVS     r2,#0xf
000078  0612              LSLS     r2,r2,#24
00007a  4391              BICS     r1,r1,r2
00007c  1182              ASRS     r2,r0,#6
00007e  1889              ADDS     r1,r1,r2
000080  6381              STR      r1,[r0,#0x38]
;;;444                        | (SYS_GPB_MFPL_PB6MFP_ADC0_CH6 ) ;
;;;445    
;;;446        SYS->GPB_MFPL = (SYS->GPB_MFPL &~(SYS_GPB_MFPL_PB5MFP_Msk | SYS_GPB_MFPL_PB4MFP_Msk| SYS_GPB_MFPL_PB3MFP_Msk)) \
000082  6b81              LDR      r1,[r0,#0x38]
000084  4a0f              LDR      r2,|L10.196|
000086  4011              ANDS     r1,r1,r2
000088  4a0f              LDR      r2,|L10.200|
00008a  1889              ADDS     r1,r1,r2
00008c  6381              STR      r1,[r0,#0x38]
;;;447                        | (SYS_GPB_MFPL_PB5MFP_ADC0_CH5 | SYS_GPB_MFPL_PB4MFP_ADC0_CH4| SYS_GPB_MFPL_PB3MFP_ADC0_CH3) ;
;;;448    
;;;449        SYS->GPB_MFPL = (SYS->GPB_MFPL &~(SYS_GPB_MFPL_PB2MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk| SYS_GPB_MFPL_PB0MFP_Msk)) \
00008e  6b81              LDR      r1,[r0,#0x38]
000090  0b09              LSRS     r1,r1,#12
000092  0309              LSLS     r1,r1,#12
000094  31ff              ADDS     r1,r1,#0xff
000096  3112              ADDS     r1,r1,#0x12
000098  6381              STR      r1,[r0,#0x38]
;;;450                        | (SYS_GPB_MFPL_PB2MFP_ADC0_CH2 | SYS_GPB_MFPL_PB1MFP_ADC0_CH1| SYS_GPB_MFPL_PB0MFP_ADC0_CH0) ;
;;;451    
;;;452        /* Set PB.0 ~ PB.3 to input mode */
;;;453        GPIO_SetMode(PB, BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6, GPIO_MODE_INPUT);
00009a  4c0c              LDR      r4,|L10.204|
00009c  2200              MOVS     r2,#0
00009e  217f              MOVS     r1,#0x7f
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       GPIO_SetMode
;;;454    
;;;455        /* Disable the PB0 ~ PB3 digital input path to avoid the leakage current. */
;;;456        GPIO_DISABLE_DIGITAL_PATH(PB, BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6);
0000a6  6861              LDR      r1,[r4,#4]
0000a8  227f              MOVS     r2,#0x7f
0000aa  0412              LSLS     r2,r2,#16
0000ac  4311              ORRS     r1,r1,r2
0000ae  6061              STR      r1,[r4,#4]
0000b0  4907              LDR      r1,|L10.208|
0000b2  2000              MOVS     r0,#0
0000b4  6008              STR      r0,[r1,#0]
;;;457    
;;;458    
;;;459        /* Lock protected registers */
;;;460        SYS_LockReg();
;;;461    }
0000b6  bd70              POP      {r4-r6,pc}
;;;462    
                          ENDP

                  |L10.184|
                          DCD      0x5f803d10
                  |L10.188|
                          DCD      0x5f400005
                  |L10.192|
                          DCD      0x6743fe1c
                  |L10.196|
                          DCD      0xff000fff
                  |L10.200|
                          DCD      0x00111000
                  |L10.204|
                          DCD      0x40004040
                  |L10.208|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1342     */
;;;1343   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1344   {
;;;1345       do {
;;;1346           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L11.24|
;;;1347           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1348           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L11.10|
00000a  6001              STR      r1,[r0,#0]            ;1346
00000c  6002              STR      r2,[r0,#0]            ;1347
00000e  6003              STR      r3,[r0,#0]
;;;1349       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L11.10|
;;;1350   }
000016  bd10              POP      {r4,pc}
;;;1351   
                          ENDP

                  |L11.24|
                          DCD      0x40000100

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;380    
;;;381    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L12.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L12.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;384        TIMER_EnableInt(TIMER3);
;;;385        NVIC_EnableIRQ(TMR3_IRQn);	
;;;386        TIMER_Start(TIMER3);
;;;387    }
000028  bd10              POP      {r4,pc}
;;;388    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x40051020
                  |L12.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;361    
;;;362    void TMR3_IRQHandler(void)
000000  480a              LDR      r0,|L13.44|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;363    {
000008  d00f              BEQ      |L13.42|
00000a  2301              MOVS     r3,#1
00000c  6083              STR      r3,[r0,#8]
;;;364    //	static uint32_t LOG = 0;
;;;365    	static uint16_t CNT = 0;
;;;366    	
;;;367        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;368        {
;;;369            TIMER_ClearIntFlag(TIMER3);
;;;370    	
;;;371    		if (CNT++ >= 1000)
00000e  4908              LDR      r1,|L13.48|
000010  8888              LDRH     r0,[r1,#4]  ; CNT
000012  1c42              ADDS     r2,r0,#1
000014  808a              STRH     r2,[r1,#4]
000016  227d              MOVS     r2,#0x7d
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d305              BCC      |L13.42|
;;;372    		{		
;;;373    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8088              STRH     r0,[r1,#4]
;;;374    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;375    			PB14 ^= 1;
000022  4804              LDR      r0,|L13.52|
000024  6b81              LDR      r1,[r0,#0x38]
000026  4059              EORS     r1,r1,r3
000028  6381              STR      r1,[r0,#0x38]
                  |L13.42|
;;;376    		}		
;;;377        }
;;;378    }
00002a  4770              BX       lr
;;;379    
                          ENDP

                  |L13.44|
                          DCD      0x40051020
                  |L13.48|
                          DCD      ||.data||
                  |L13.52|
                          DCD      0x40004840

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;389    
;;;390    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;391    {
;;;392        SYS_ResetModule(UART0_RST);
000002  4813              LDR      r0,|L14.80|
000004  f7fffffe          BL       SYS_ResetModule
;;;393    
;;;394        /* Configure UART0 and set UART0 baud rate */
;;;395        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4811              LDR      r0,|L14.84|
00000e  f7fffffe          BL       UART_Open
;;;396    
;;;397    	/* Set UART receive time-out */
;;;398    //	UART_SetTimeoutCnt(UART0, 20);
;;;399    
;;;400    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000012  f7fffffe          BL       CLK_GetCPUFreq
000016  4601              MOV      r1,r0
000018  a00f              ADR      r0,|L14.88|
00001a  f7fffffe          BL       __2printf
;;;401    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001e  f7fffffe          BL       CLK_GetHXTFreq
000022  4601              MOV      r1,r0
000024  a013              ADR      r0,|L14.116|
000026  f7fffffe          BL       __2printf
;;;402    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00002a  f7fffffe          BL       CLK_GetLXTFreq
00002e  4601              MOV      r1,r0
000030  a016              ADR      r0,|L14.140|
000032  f7fffffe          BL       __2printf
;;;403    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  4601              MOV      r1,r0
00003c  a019              ADR      r0,|L14.164|
00003e  f7fffffe          BL       __2printf
;;;404    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000042  f7fffffe          BL       CLK_GetPCLK1Freq
000046  4601              MOV      r1,r0
000048  a01d              ADR      r0,|L14.192|
00004a  f7fffffe          BL       __2printf
;;;405    }
00004e  bd10              POP      {r4,pc}
;;;406    
                          ENDP

                  |L14.80|
                          DCD      0x04000010
                  |L14.84|
                          DCD      0x40070000
                  |L14.88|
000058  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00005c  4b5f4765
000060  74435055
000064  46726571
000068  203a2025
00006c  38640d0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L14.116|
000074  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000078  47657448
00007c  58544672
000080  6571203a
000084  20253864
000088  0d0a00  
00008b  00                DCB      0
                  |L14.140|
00008c  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000090  4765744c
000094  58544672
000098  6571203a
00009c  20253864
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L14.164|
0000a4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000a8  47657450
0000ac  434c4b30
0000b0  46726571
0000b4  203a2025
0000b8  38640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L14.192|
0000c0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000c4  47657450
0000c8  434c4b31
0000cc  46726571
0000d0  203a2025
0000d4  38640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.convertDecToBin||, CODE, READONLY, ALIGN=2

                  convertDecToBin PROC
;;;182    
;;;183    void convertDecToBin(int n)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;184    {
000002  b082              SUB      sp,sp,#8
;;;185        int k = 0;
000004  2500              MOVS     r5,#0
;;;186        unsigned char *p = (unsigned char*)&n;
000006  a802              ADD      r0,sp,#8
;;;187        int val2 = 0;
;;;188        int i = 0;
;;;189        for(k = 0; k <= 1; k++)
;;;190        {
;;;191            val2 = *(p+k);
;;;192            for (i = 7; i >= 0; i--)
;;;193            {
;;;194                if(val2 & (1 << i))
000008  2701              MOVS     r7,#1
00000a  9000              STR      r0,[sp,#0]
                  |L15.12|
00000c  9800              LDR      r0,[sp,#0]            ;191
00000e  2407              MOVS     r4,#7                 ;192
000010  5d46              LDRB     r6,[r0,r5]            ;191
                  |L15.18|
000012  4638              MOV      r0,r7
000014  40a0              LSLS     r0,r0,r4
000016  4230              TST      r0,r6
000018  d001              BEQ      |L15.30|
;;;195                    printf("1");
00001a  a007              ADR      r0,|L15.56|
00001c  e000              B        |L15.32|
                  |L15.30|
;;;196                else
;;;197                    printf("0");
00001e  a007              ADR      r0,|L15.60|
                  |L15.32|
000020  f7fffffe          BL       __2printf
000024  1e64              SUBS     r4,r4,#1
000026  d5f4              BPL      |L15.18|
;;;198            }
;;;199            printf(" ");
000028  a005              ADR      r0,|L15.64|
00002a  f7fffffe          BL       __2printf
00002e  1c6d              ADDS     r5,r5,#1
000030  2d01              CMP      r5,#1                 ;189
000032  ddeb              BLE      |L15.12|
;;;200        }
;;;201    }
000034  bdfe              POP      {r1-r7,pc}
;;;202    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
000038  3100              DCB      "1",0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L15.60|
00003c  3000              DCB      "0",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L15.64|
000040  2000              DCB      " ",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;470    
;;;471    int main()
000000  f7fffffe          BL       SYS_Init
;;;472    {
;;;473        SYS_Init();
;;;474    
;;;475        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;476    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;477    	TIMER3_Init();
00000c  f7fffffe          BL       TIMER3_Init
;;;478    	
;;;479        /* Enable ADC converter */
;;;480        ADC_POWER_ON(ADC);
000010  4807              LDR      r0,|L16.48|
000012  6801              LDR      r1,[r0,#0]
000014  2201              MOVS     r2,#1
000016  4311              ORRS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;481    
;;;482        /*Wait for ADC internal power ready*/
;;;483        CLK_SysTickDelay(10000);
00001a  4806              LDR      r0,|L16.52|
00001c  f7fffffe          BL       CLK_SysTickDelay
;;;484    
;;;485        PDMA_Init();
000020  f7fffffe          BL       PDMA_Init
;;;486    	
;;;487    	ADC_Process(State_avergage);
000024  2000              MOVS     r0,#0
                  |L16.38|
000026  f7fffffe          BL       ADC_Process
;;;488    
;;;489        /* Got no where to go, just loop forever */
;;;490        while(1)
;;;491        {
;;;492    		ADC_Process(State_moving);
00002a  2001              MOVS     r0,#1
00002c  e7fb              B        |L16.38|
;;;493    		
;;;494        }
;;;495    }
;;;496    
                          ENDP

00002e  0000              DCW      0x0000
                  |L16.48|
                          DCD      0x40043080
                  |L16.52|
                          DCD      0x00002710

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ADC_DataArray
                          %        14

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  adc_measure
000000  00010203          DCB      0x00,0x01,0x02,0x03
000004  04050610          DCB      0x04,0x05,0x06,0x10
                  __FUNCTION__
000008  50444d41          DCB      0x50,0x44,0x4d,0x41
00000c  5f495251          DCB      0x5f,0x49,0x52,0x51
000010  48616e64          DCB      0x48,0x61,0x6e,0x64
000014  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ADC_TargetChannel
000000  0000              DCW      0x0000
                  PDMAConvertedData
000002  0000              DCW      0x0000
                  ||CNT||
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  AVdd
                          DCD      0x00000000
                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  ADC_State
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d652c64e____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d652c64e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d652c64e____REVSH|
#line 402
|__asm___6_main_c_d652c64e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
